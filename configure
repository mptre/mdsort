#!/bin/sh

set -e

atexit() {
	err=$?

	# Dump contents of generated files to config.log.
	set -x
	cat config.h
	cat Makefile.inc
	rm -f "$@"
	[ $err -ne 0 ] && fatal
	exit 0
}

compile() {
	$CC -Werror -o /dev/null -x c -
}

fatal() {
	[ $# -gt 0 ] && echo "fatal: ${*}"
	exec 1>&3 2>&4
	cat config.log
	return 1
}

headers() {
	cat >"$TMP"
	[ -s "$TMP" ] || return 0

	xargs printf '#include <%s>\n' <"$TMP"
}

makevar() {
	make -sf - <<EOF
all:
	@echo \${${1}}
EOF
}

check_arc4random() {
	compile <<-EOF
	#include <stdlib.h>

	int main(void) {
		return !(arc4random() <= 0xffffffff);
	}
	EOF
}

check_dead() {
	compile <<-EOF
	#include <stdlib.h>

	__dead int dead(void);

	int main(void) {
		return 0;
	}
	EOF
}

check_errc() {
	compile <<-EOF
	#include <err.h>

	int main(void) {
		errc(1, 0, "");
		return 0;
	}
	EOF
}

# Check if strptime(3) is hidden behind _GNU_SOURCE.
check_gnu_source() {
	compile <<-EOF && return 1
	#include <time.h>

	int main(void) {
		struct tm tm;
		return !(strptime("0", "%s", &tm) != NULL);
	}
	EOF

	compile <<-EOF
	#define _GNU_SOURCE
	#include <time.h>

	int main(void) {
		struct tm tm;
		return !(strptime("0", "%s", &tm) != NULL);
	}
	EOF
}

check_host_name_max() {
	compile <<-EOF
	#include <limits.h>

	int main(void) {
		static char hostname[HOST_NAME_MAX + 1];
		return !(hostname[0] == '\0');
	}
	EOF
}

check_malloc_options() {
	case "$(uname -s)" in
	OpenBSD)	echo "RS";;
	esac
}

check_pledge() {
	compile <<-EOF
	#include <unistd.h>

	int main(void) {
		return !(pledge("stdio", NULL) == 0);
	}
	EOF
}

check_queue() {
	compile <<-EOF
	#include <sys/queue.h>

	int main(void) {
		return 0;
	}
	EOF
}

check_reallocarray() {
	compile <<-EOF
	#include <stdlib.h>

	int main(void) {
		return !(reallocarray(NULL, 1, 1) != NULL);
	}
	EOF
}

check_stat_tim() {
	compile <<-EOF
	#include <sys/stat.h>

	int main(void) {
		struct stat st;

		if (stat("/var/empty", &st) == -1)
			return 1;
		return !(st.st_mtim.tv_sec > 0);
	}
	EOF
}

check_strlcpy() {
	compile <<-EOF
	#include <string.h>

	int main(void) {
		char buf[128];

		return !(strlcpy(buf, "strlcpy", sizeof(buf)) < sizeof(buf));
	}
	EOF
}

check_utimensat() {
	compile <<-EOF
	#include <sys/time.h>
	#include <sys/stat.h>
	#include <fcntl.h>

	int main(void) {
		struct timespec times[2] = { { 0, 0 }, { 0, 0 } };
		return !(utimensat(0, "/var/empty", times, 0) != -1);
	}
	EOF
}

check_warnc() {
	compile <<-EOF
	#include <err.h>

	int main(void) {
		warnc(1, "");
		return 0;
	}
	EOF
}

HAVE_ARC4RANDOM=0
HAVE_DEAD=0
HAVE_ERRC=0
HAVE_GNU_SOURCE=0
HAVE_HOST_NAME_MAX=0
HAVE_PLEDGE=0
HAVE_QUEUE=0
HAVE_REALLOCARRAY=0
HAVE_STAT_TIM=0
HAVE_STRLCPY=0
HAVE_UTIMENSAT=0
HAVE_WARNC=0

CC=$(makevar CC)
CFLAGS=$(makevar CFLAGS)
CFLAGS="${CFLAGS} ${DEBUG} -Wall -Wextra -MD -MP"
INSTALL=$(makevar INSTALL)
SHA256=$(which sha256sum sha256 2>/dev/null | head -1)
YACC=$(makevar YACC)

: "${CPPFLAGS:=}"
: "${DEBUG:=}"
: "${INSTALL:=install}"
: "${LDFLAGS:=}"
: "${SHA256:=false}"
: "${YFLAGS:=}"

exec 3>&1 4>&2
exec 1>config.log 2>&1

TMP=$(mktemp -t configure.XXXXXX)
trap "atexit $TMP" EXIT

# At this point, all variables used must be defined.
set -u
# Enable tracing, will end up in config.log.
set -x

[ -z "$YACC" ] && fatal "cannot find yacc"

check_arc4random && HAVE_ARC4RANDOM=1
check_dead && HAVE_DEAD=1
check_errc && HAVE_ERRC=1
check_gnu_source && HAVE_GNU_SOURCE=1
check_host_name_max && HAVE_HOST_NAME_MAX=1
check_pledge && HAVE_PLEDGE=1
check_queue && HAVE_QUEUE=1
check_reallocarray && HAVE_REALLOCARRAY=1
check_stat_tim && HAVE_STAT_TIM=1
check_strlcpy && HAVE_STRLCPY=1
check_utimensat && HAVE_UTIMENSAT=1
check_warnc && HAVE_WARNC=1

MALLOC_OPTIONS=$(check_malloc_options)

# Order is important, must be present before any includes.
(
[ $HAVE_GNU_SOURCE -eq 1 ] && printf '#define _GNU_SOURCE\n'

# Ensure this subshell always exits 0.
true
) >config.h

# Headers needed for function prototypes.
(
[ $HAVE_ARC4RANDOM -eq 0 ] && echo stdint.h
[ $HAVE_PLEDGE -eq 0 ] && echo stdlib.h
[ $HAVE_REALLOCARRAY -eq 0 ] && echo stdlib.h
[ $HAVE_STRLCPY -eq 0 ] && echo stdlib.h
[ $HAVE_UTIMENSAT -eq 0 ] && echo sys/time.h
) | sort | uniq | headers >>config.h

(
[ $HAVE_ARC4RANDOM -eq 1 ] && printf '#define HAVE_ARC4RANDOM\t1\n'
[ $HAVE_ERRC -eq 1 ] && printf '#define HAVE_ERRC\t1\n'
[ $HAVE_PLEDGE -eq 1 ] && printf '#define HAVE_PLEDGE\t1\n'
[ $HAVE_QUEUE -eq 1 ] && printf '#define HAVE_QUEUE\t1\n'
[ $HAVE_REALLOCARRAY -eq 1 ] && printf '#define HAVE_REALLOCARRAY\t1\n'
[ $HAVE_STRLCPY -eq 1 ] && printf '#define HAVE_STRLCPY\t1\n'
[ $HAVE_UTIMENSAT -eq 1 ] && printf '#define HAVE_UTIMENSAT\t1\n'
[ $HAVE_WARNC -eq 1 ] && printf '#define HAVE_WARNC\t1\n'

[ $HAVE_DEAD -eq 0 ] && printf '#define __dead\n'

[ $HAVE_HOST_NAME_MAX -eq 0 ] && printf '#define HOST_NAME_MAX\t255\n'

if [ $HAVE_STAT_TIM -eq 0 ]; then
	printf '#define st_atim\tst_atimespec\n'
	printf '#define st_ctim\tst_ctimespec\n'
	printf '#define st_mtim\tst_mtimespec\n'
fi

[ $HAVE_UTIMENSAT -eq 0 ] && printf '#define UTIME_OMIT -1L\n'

[ $HAVE_ARC4RANDOM -eq 0 ] && \
	printf 'uint32_t arc4random(void);\n'
[ $HAVE_ERRC -eq 0 ] && {
	printf 'void errc(int eval, int code, const char *fmt, ...)\n';
	printf '\t__attribute__((__noreturn__, __format__ (printf, 3, 4)));\n'; }
[ $HAVE_PLEDGE -eq 0 ] && \
	printf 'int pledge(const char *, const char *);\n'
[ $HAVE_REALLOCARRAY -eq 0 ] && \
	printf 'void *reallocarray(void *, size_t, size_t);\n'
[ $HAVE_STRLCPY -eq 0 ] && \
	printf 'size_t strlcpy(char *, const char *, size_t);\n'
[ $HAVE_UTIMENSAT -eq 0 ] && \
	printf 'int utimensat(int, const char *, const struct timespec [2], int);\n'
[ $HAVE_WARNC -eq 0 ] && {
	printf 'void warnc(int code, const char *fmt, ...)\n'
	printf '\t__attribute__((__format__ (printf, 2, 3)));\n'; }

# Ensure this subshell always exits 0.
true
) >>config.h

# Use echo to normalize whitespace.
cat <<EOF >Makefile.inc
CC=		$(echo $CC)
CFLAGS=		$(echo $CFLAGS)
CPPFLAGS=	$(echo $CPPFLAGS)
DEBUG=		$(echo $DEBUG)
INSTALL=	$(echo $INSTALL)
LDFLAGS=	$(echo $LDFLAGS)
MALLOC_OPTIONS=	$(echo $MALLOC_OPTIONS)
SHA256=		$(echo $SHA256)
YACC=		$(echo $YACC)
YFLAGS=		$(echo $YFLAGS)
EOF
